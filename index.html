<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dynamic Days Grid (Cloud Sync)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Markdown renderer -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    .prose p { margin: 0.5rem 0; }
    .prose h1, .prose h2, .prose h3 { font-weight: 600; margin-top: 1rem; }
    .prose ul { list-style: disc; padding-left: 1.5rem; }
    .prose ol { list-style: decimal; padding-left: 1.5rem; }
    .prose code { background: #f1f5f9; padding: 0 .25rem; border-radius: .25rem; }
    .prose pre { background: #0f172a; color: white; padding: .75rem; border-radius: .5rem; overflow:auto; }
  </style>
</head>
<body class="bg-slate-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useRef, useState } = React;

    const MAX_PAGES = 51;
    const AUTO_RELOCK_MS = 24 * 60 * 60 * 1000;
    const ALLOWED_COLORS = ["#000000", "#FF0000", "#2196F3", "#008000"];

    // ===== JSONBIN CONSTANTS =====
    const JSONBIN_BASE = "https://api.jsonbin.io/v3";
    const BIN_NAME = "dynamic-days-grid";
    const LSK_MASTER_KEY = "jsonbin_master_key";
    const LSK_BIN_ID = "jsonbin_bin_id";

    const cls = (...xs) => xs.filter(Boolean).join(" ");

    function toast(msg) {
      const el = document.createElement("div");
      el.textContent = msg;
      el.className =
        "fixed left-1/2 -translate-x-1/2 bottom-6 z-[9999] rounded-xl bg-black/80 text-white px-4 py-2 text-sm shadow-lg";
      document.body.appendChild(el);
      setTimeout(() => {
        el.style.transition = "opacity .25s ease";
        el.style.opacity = "0";
        setTimeout(() => el.remove(), 250);
      }, 1600);
    }

    function downloadJson(filename, dataObj) {
      const blob = new Blob([JSON.stringify(dataObj, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function openFilePickerJson() {
      return new Promise((resolve, reject) => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json,application/json";
        input.onchange = async () => {
          const file = input.files && input.files[0];
          if (!file) return reject(new Error("No file selected"));
          const text = await file.text();
          try {
            const json = JSON.parse(text);
            resolve(json);
          } catch (e) {
            reject(e);
          }
        };
        input.click();
      });
    }

    function lsGet(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : fallback;
      } catch (e) {
        return fallback;
      }
    }
    function lsSet(key, value) {
      localStorage.setItem(key, JSON.stringify(value));
    }

    // ====== JSONBIN HELPERS (Create / Read / Update) ======
    function getMasterKey() {
      return lsGet(LSK_MASTER_KEY, "");
    }
    function setMasterKey(k) {
      lsSet(LSK_MASTER_KEY, k);
    }
    function getBinId() {
      return lsGet(LSK_BIN_ID, "");
    }
    function setBinId(id) {
      lsSet(LSK_BIN_ID, id);
    }

    async function jsonbinCreate(record) {
      const key = getMasterKey();
      if (!key) throw new Error("No Master Key set");
      const res = await fetch(`${JSONBIN_BASE}/b`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Master-Key": key,                 // Master key
          "X-Bin-Private": "true",             // make bin private
          "X-Bin-Name": BIN_NAME               // optional: name
        },
        body: JSON.stringify({ record })
      });
      if (!res.ok) {
        const t = await res.text().catch(() => "");
        throw new Error(`Create failed (${res.status}): ${t || res.statusText}`);
      }
      const data = await res.json();
      // v3 returns {metadata:{id:...}, record:{...}}
      const id = data?.metadata?.id;
      if (!id) throw new Error("Create succeeded but no Bin ID returned");
      return id;
    }

    async function jsonbinUpdate(binId, record) {
      const key = getMasterKey();
      if (!key) throw new Error("No Master Key set");
      const res = await fetch(`${JSONBIN_BASE}/b/${encodeURIComponent(binId)}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          "X-Master-Key": key
        },
        body: JSON.stringify({ record })
      });
      if (!res.ok) {
        const t = await res.text().catch(() => "");
        throw new Error(`Update failed (${res.status}): ${t || res.statusText}`);
      }
      const data = await res.json();
      return data;
    }

    async function jsonbinRead(binId) {
      const key = getMasterKey();
      const url = `${JSONBIN_BASE}/b/${encodeURIComponent(binId)}/latest`;
      const headers = { };
      // If bin is private, key needed; if public, it works without.
      if (key) headers["X-Master-Key"] = key;
      const res = await fetch(url, { headers });
      if (!res.ok) {
        const t = await res.text().catch(() => "");
        throw new Error(`Read failed (${res.status}): ${t || res.statusText}`);
      }
      const data = await res.json();
      // v3 returns {record:...}
      return data?.record;
    }

    // ====== EXISTING STORAGE SHAPE ======
    function loadDay(dayIndex) {
      const pages = lsGet(`day_${dayIndex}_pages`, null);
      const styles = lsGet(`day_${dayIndex}_styles`, null);
      const locks = lsGet(`day_${dayIndex}_locks`, null);
      return { pages, styles, locks };
    }

    function saveDay(dayIndex, payload) {
      const pages = payload.pages;
      const styles = payload.styles != null ? payload.styles : [];
      const locks = payload.locks != null ? payload.locks : { page: [], fieldLocked: [] };
      lsSet(`day_${dayIndex}_pages`, pages);
      lsSet(`day_${dayIndex}_styles`, styles);
      lsSet(`day_${dayIndex}_locks`, locks);
    }

    function ensureDayShape(dayIndex, state) {
      let pages = state.pages;
      let styles = state.styles;
      let locks = state.locks;

      if (!pages) pages = [[""]];
      if (!locks) locks = { page: [], fieldLocked: [] };

      while (locks.page.length < pages.length) {
        locks.page.push({ locked: false, password: "", hint: "", lastUnlock: 0 });
      }
      while (locks.fieldLocked.length < pages.length) {
        locks.fieldLocked.push([]);
      }
      for (let p = 0; p < pages.length; p++) {
        while (locks.fieldLocked[p].length < pages[p].length) locks.fieldLocked[p].push(false);
      }
      if (!styles) styles = [];
      return { pages, styles, locks };
    }

    // ===== UI BUTTONS =====
    function IconBtn(props) {
      const { title, onClick, children, disabled } = props;
      return (
        <button
          title={title}
          onClick={onClick}
          disabled={disabled}
          className={cls(
            "inline-flex items-center justify-center rounded-lg p-2 hover:bg-black/5 disabled:opacity-40 disabled:cursor-not-allowed"
          )}
        >
          {children}
        </button>
      );
    }

    function PrimaryBtn(props) {
      const { children, onClick, className, disabled } = props;
      return (
        <button
          onClick={onClick}
          disabled={disabled}
          className={cls(
            "px-4 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700 shadow-sm disabled:opacity-40",
            className
          )}
        >
          {children}
        </button>
      );
    }

    function OutlineBtn(props) {
      const { children, onClick, className, disabled } = props;
      return (
        <button
          onClick={onClick}
          disabled={disabled}
          className={cls(
            "px-4 py-2 rounded-xl border border-black/10 hover:bg-black/5 disabled:opacity-40",
            className
          )}
        >
          {children}
        </button>
      );
    }

    // ===== Grid Manager =====
    function GridManagerPage(props) {
      const { onBack } = props;
      const [items, setItems] = React.useState(() => lsGet("grid_manager_items", [
        "Grid 1",
        "Grid 2",
        "Grid 3",
        "Grid 4",
      ]));

      React.useEffect(() => lsSet("grid_manager_items", items), [items]);

      function addItem() {
        setItems(prev => prev.concat(["Grid " + (prev.length + 1)]));
      }
      function removeAt(idx) {
        setItems(prev => prev.filter((_, i) => i !== idx));
      }
      function editAt(idx) {
        const next = prompt("Edit grid text", items[idx]);
        if (next && next.trim()) {
          setItems(prev => prev.map((v, i) => i === idx ? next.trim() : v));
        }
      }

      return (
        <div className="min-h-screen bg-gradient-to-b from-white to-slate-50">
          <header className="sticky top-0 z-10 backdrop-blur bg-white/70 border-b border-black/10">
            <div className="max-w-6xl mx-auto px-4 py-3 flex items-center gap-2">
              <OutlineBtn onClick={onBack}>← Back</OutlineBtn>
              <h1 className="text-xl font-semibold">Grid Manager</h1>
              <div className="flex-1" />
              <PrimaryBtn onClick={addItem}>Add New Grid</PrimaryBtn>
            </div>
          </header>

          <main className="max-w-6xl mx-auto px-4 py-6">
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
              {items.map((label, idx) => (
                <div
                  key={idx}
                  onClick={() => editAt(idx)}
                  onContextMenu={(e) => { e.preventDefault(); removeAt(idx); }}
                  className="rounded-xl bg-blue-100 shadow-sm hover:shadow cursor-pointer select-none p-6 flex items-center justify-center text-center"
                >
                  <span className="font-semibold text-slate-900">{label}</span>
                </div>
              ))}
            </div>
            <p className="mt-4 text-sm text-slate-500">Tip: right-click a tile to remove it.</p>
          </main>
        </div>
      );
    }

    // ===== Day Text Page =====
    function DayTextPage(props) {
      const { dayIndex, onBack } = props;
      const [state, setState] = useState(() => ensureDayShape(dayIndex, loadDay(dayIndex)));
      const [currentPage, setCurrentPage] = useState(0);
      const [isSearching, setIsSearching] = useState(false);
      const [query, setQuery] = useState("");
      const [searchResults, setSearchResults] = useState([]);
      const [currentResultIdx, setCurrentResultIdx] = useState(0);

      const [editable, setEditable] = useState(() => state.pages.map(fields => fields.map(() => false)));

      const textRefs = useRef([]);
      if (textRefs.current.length !== state.pages.length) {
        textRefs.current = state.pages.map((fields, p) => (textRefs.current[p] || []).slice(0, fields.length));
      }

      useEffect(() => { saveDay(dayIndex, state); }, [dayIndex, state]);

      useEffect(() => {
        setState(prev => {
          const next = ensureDayShape(dayIndex, prev);
          for (let p = 0; p < next.pages.length; p++) {
            const meta = next.locks.page[p];
            if (!meta) continue;
            if (!meta.locked && meta.lastUnlock) {
              if (Date.now() - meta.lastUnlock >= AUTO_RELOCK_MS) {
                meta.locked = true;
                meta.lastUnlock = 0;
              }
            }
          }
          return { ...next };
        });
      }, [dayIndex]);

      function addPage() {
        setState(prev => {
          if (prev.pages.length >= MAX_PAGES) {
            toast("Maximum pages reached");
            return prev;
          }
          const pages = prev.pages.concat([[""]]);
          const locks = {
            page: prev.locks.page.concat([{ locked: false, password: "", hint: "", lastUnlock: 0 }]),
            fieldLocked: prev.locks.fieldLocked.concat([[false]]),
          };
          const styles = (prev.styles || []).slice();
          setEditable(old => old.concat([[false]]));
          return { pages, locks, styles };
        });
        setCurrentPage(i => i + 1);
      }

      function deleteCurrentPage() {
        setState(prev => {
          if (prev.pages.length <= 1) {
            toast("Cannot delete last page");
            return prev;
          }
          const p = currentPage;
          const pages = prev.pages.filter((_, i) => i !== p);
          const locks = {
            page: prev.locks.page.filter((_, i) => i !== p),
            fieldLocked: prev.locks.fieldLocked.filter((_, i) => i !== p),
          };
          const styles = prev.styles;
          setEditable(old => old.filter((_, i) => i !== p));
          const nextIndex = Math.min(pages.length - 1, p);
          setCurrentPage(nextIndex);
          return { pages, locks, styles };
        });
      }

      function addTextField() {
        setState(prev => {
          const pages = prev.pages.map((fields, i) => i === currentPage ? fields.concat([""]) : fields);
          const locks = {
            page: prev.locks.page,
            fieldLocked: prev.locks.fieldLocked.map((arr, i) => i === currentPage ? arr.concat([false]) : arr),
          };
          const styles = prev.styles;
          setEditable(old => old.map((row, i) => i === currentPage ? row.concat([false]) : row));
          return { pages, locks, styles };
        });
      }

      function deleteTextField(pageIdx, fieldIdx) {
        setState(prev => {
          const pages = prev.pages.map((fields, i) => i === pageIdx ? fields.filter((_, j) => j !== fieldIdx) : fields);
          const locks = {
            page: prev.locks.page,
            fieldLocked: prev.locks.fieldLocked.map((arr, i) => i === pageIdx ? arr.filter((_, j) => j !== fieldIdx) : arr),
          };
          const styles = prev.styles;
          setEditable(old => old.map((row, i) => i === pageIdx ? row.filter((_, j) => j !== fieldIdx) : row));
          return { pages, locks, styles };
        });
      }

      function toggleEdit(p, f) {
        if (state.locks.fieldLocked[p][f]) return;
        setEditable(old => old.map((row, i) => i === p ? row.map((v, j) => j === f ? !v : false) : row));
      }

      function toggleFieldLock(p, f) {
        setEditable(old => old.map((row, i) => i === p ? row.map((v, j) => j === f ? false : v) : row));
        setState(prev => {
          const locks = {
            page: prev.locks.page,
            fieldLocked: prev.locks.fieldLocked.map((arr, i) => i === p ? arr.map((v, j) => j === f ? !v : v) : arr),
          };
          return { ...prev, locks };
        });
      }

      function updateField(p, f, val) {
        setState(prev => {
          const pages = prev.pages.map((fields, i) => i === p ? fields.map((t, j) => j === f ? val : t) : fields);
          return { ...prev, pages };
        });
      }

      async function sendClipboardToPage51() {
        try {
          const text = await navigator.clipboard.readText();
          if (!text || !text.trim()) {
            toast("No text in clipboard");
            return;
          }
          setState(prev => {
            const pages = prev.pages.slice();
            while (pages.length < 51) pages.push([""]);
            const p = 50;
            if (pages[p].length === 0) pages[p] = [""];
            const cur = pages[p][0] || "";
            pages[p][0] = cur ? (cur + ", " + text.trim()) : text.trim();
            return { ...prev, pages };
          });
          toast("Clipboard text sent to page 51");
        } catch (e) {
          toast("Clipboard access was blocked by the browser");
        }
      }

      function lockCurrentPage() {
        const pwd = prompt("Set password for this page:");
        if (!pwd) {
          toast("Password cannot be empty");
          return;
        }
        const hint = prompt("Hint (optional):") || "";
        setState(prev => {
          const locks = { ...prev.locks };
          locks.page[currentPage] = { locked: true, password: pwd, hint, lastUnlock: 0 };
          return { ...prev, locks };
        });
      }

      function attemptUnlock(pageIdx) {
        const meta = state.locks.page[pageIdx];
        const pwd = prompt("Enter password" + (meta && meta.hint ? (" (hint: " + meta.hint + ")") : ""));
        if (pwd === null) return;
        if (pwd === (meta && meta.password ? meta.password : "")) {
          setState(prev => {
            const locks = { ...prev.locks };
            locks.page[pageIdx] = { ...locks.page[pageIdx], locked: false, lastUnlock: Date.now() };
            return { ...prev, locks };
          });
        } else {
          toast("Incorrect password");
        }
      }

      function performSearch(q) {
        const num = Number(q);
        if (!Number.isNaN(num) && String(num) === q.trim()) {
          const idx = num - 1;
          if (idx >= 0 && idx < state.pages.length) {
            setCurrentPage(idx);
          } else {
            toast("Page " + num + " not found");
          }
          return;
        }

        const results = [];
        if (q.trim()) {
          for (let p = 0; p < state.pages.length; p++) {
            const meta = state.locks.page[p];
            if (meta && meta.locked) continue;
            for (let f = 0; f < state.pages[p].length; f++) {
              const txt = state.pages[p][f] || "";
              let start = 0;
              const low = txt.toLowerCase();
              const qlow = q.toLowerCase();
              while (true) {
                const at = low.indexOf(qlow, start);
                if (at === -1) break;
                results.push({ pageIndex: p, fieldIndex: f, matchStart: at, matchEnd: at + q.length });
                start = at + q.length;
              }
            }
          }
        }

        setSearchResults(results);
        if (results.length) {
          goToSearchResult(0, results);
        } else if (q.trim()) {
          toast('No results for "' + q + '"');
        }
      }

      function goToSearchResult(nextIdx, results) {
        if (!results) results = searchResults;
        if (!results.length) return;
        const r = results[nextIdx];
        setCurrentPage(r.pageIndex);
        if (!state.locks.fieldLocked[r.pageIndex][r.fieldIndex]) {
          setEditable(old =>
            old.map((row, i) =>
              i === r.pageIndex ? row.map((v, j) => j === r.fieldIndex ? true : false) : row
            )
          );
        }
        setTimeout(() => {
          const el = textRefs.current?.[r.pageIndex]?.[r.fieldIndex];
          if (el && el.setSelectionRange) {
            try {
              el.focus();
              el.setSelectionRange(r.matchStart, r.matchEnd);
            } catch (e) {}
          }
        }, 0);
        setCurrentResultIdx(nextIdx);
      }

      function goPrevResult() {
        if (!searchResults.length) return;
        const n = (currentResultIdx - 1 + searchResults.length) % searchResults.length;
        goToSearchResult(n);
      }
      function goNextResult() {
        if (!searchResults.length) return;
        const n = (currentResultIdx + 1) % searchResults.length;
        goToSearchResult(n);
      }

      const pageLocked = state.locks.page[currentPage]?.locked;

      return (
        <div className="min-h-screen bg-gradient-to-b from-white to-slate-50">
          <header className="sticky top-0 z-10 backdrop-blur bg-white/70 border-b border-black/10">
            <div className="max-w-6xl mx-auto px-3 py-2 flex items-center gap-2">
              <OutlineBtn onClick={onBack}>← Back</OutlineBtn>

              <div className="flex-1 flex items-center justify-center">
                {isSearching ? (
                  <div className="w-full max-w-xl flex items-center gap-2">
                    <input
                      autoFocus
                      className="flex-1 rounded-xl border border-black/10 px-3 py-2 outline-none"
                      placeholder="Search… or enter page"
                      value={query}
                      onChange={(e) => setQuery(e.target.value)}
                      onKeyDown={(e) => { if (e.key === "Enter") performSearch(query); }}
                    />
                    <PrimaryBtn onClick={() => performSearch(query)}>Search</PrimaryBtn>
                  </div>
                ) : (
                  <div className="flex items-center gap-3">
                    <IconBtn title="Clipboard → page 51" onClick={sendClipboardToPage51}>
                      <span className="i">📋</span>
                    </IconBtn>
                    <div className="text-lg font-semibold">Page {currentPage + 1} / {state.pages.length}</div>
                  </div>
                )}
              </div>

              <div className="flex items-center gap-1">
                {isSearching && searchResults.length > 1 && (
                  <>
                    <IconBtn title="Prev" onClick={goPrevResult}>◀</IconBtn>
                    <IconBtn title="Next" onClick={goNextResult}>▶</IconBtn>
                  </>
                )}
                <IconBtn
                  title={isSearching ? "Close search" : "Search"}
                  onClick={() => {
                    if (isSearching) {
                      setIsSearching(false);
                      setQuery("");
                      setSearchResults([]);
                    } else {
                      setIsSearching(true);
                    }
                  }}
                >
                  🔍
                </IconBtn>
              </div>
            </div>
          </header>

          <main className="max-w-5xl mx-auto px-3 py-4">
            {pageLocked ? (
              <div className="flex items-center justify-center py-24">
                <div className="rounded-2xl border border-black/10 shadow p-8 text-center bg-white">
                  <div className="text-6xl">🔒</div>
                  <div className="mt-4 text-xl font-semibold">This page is locked</div>
                  {state.locks.page[currentPage]?.hint ? (
                    <div className="mt-2 italic text-slate-600">Hint: {state.locks.page[currentPage].hint}</div>
                  ) : null}
                  <PrimaryBtn className="mt-6" onClick={() => attemptUnlock(currentPage)}>
                    Unlock
                  </PrimaryBtn>
                </div>
              </div>
            ) : (
              <div className="space-y-4">
                {state.pages[currentPage].map((text, fIdx) => {
                  const isLocked = state.locks.fieldLocked[currentPage][fIdx];
                  const isEdit = editable[currentPage]?.[fIdx];

                  return (
                    <div key={fIdx} className="rounded-xl border border-black/10 bg-white shadow-sm p-3">
                      <div className="flex items-center justify-end gap-1">
                        <IconBtn title="Clipboard → page 51" onClick={sendClipboardToPage51}>📋</IconBtn>
                        <IconBtn title="Delete field" onClick={() => deleteTextField(currentPage, fIdx)}>🗑️</IconBtn>
                        <IconBtn title="Edit field" onClick={() => { if (!isLocked) toggleEdit(currentPage, fIdx); }}>
                          ✏️
                        </IconBtn>
                        <IconBtn
                          title={isLocked ? "Unlock field" : "Lock field"}
                          onClick={() => toggleFieldLock(currentPage, fIdx)}
                        >
                          {isLocked ? "🔒" : "🔓"}
                        </IconBtn>
                      </div>

                      {isEdit ? (
                        <textarea
                          ref={(el) => {
                            textRefs.current[currentPage] = textRefs.current[currentPage] || [];
                            textRefs.current[currentPage][fIdx] = el;
                          }}
                          value={text}
                          onChange={(e) => updateField(currentPage, fIdx, e.target.value)}
                          className="w-full min-h-[120px] rounded-lg outline-none resize-y px-3 py-2"
                          style={{ color: ALLOWED_COLORS[0], fontSize: 16 }}
                          placeholder="Write Markdown…"
                        />
                      ) : (
                        <div
                          className="prose max-w-none"
                          dangerouslySetInnerHTML={{ __html: (window.marked ? window.marked.parse(text || "") : (text || "")) }}
                        />
                      )}
                    </div>
                  );
                })}
              </div>
            )}

            <div className="mt-6 flex items-center justify-center gap-3">
              <PrimaryBtn onClick={addTextField}>Add Text</PrimaryBtn>
              <OutlineBtn onClick={deleteCurrentPage}>Delete</OutlineBtn>
              {pageLocked ? (
                <PrimaryBtn onClick={() => attemptUnlock(currentPage)}>Unlock</PrimaryBtn>
              ) : (
                <OutlineBtn onClick={lockCurrentPage}>Lock</OutlineBtn>
              )}
            </div>
          </main>
        </div>
      );
    }

    // ===== Day Grid Page (adds Cloud menu) =====
    function DayGridPage(props) {
      const { onOpenDay, onOpenGridManager } = props;
      const [days, setDays] = useState(() => {
        const saved = lsGet("days_names", null);
        if (Array.isArray(saved) && saved.length) return saved;
        const arr = [];
        for (let i = 0; i < 150; i++) arr.push("Day " + (i + 1));
        return arr;
      });
      const [cloudOpen, setCloudOpen] = useState(false);
      const [busy, setBusy] = useState(false);

      useEffect(() => { lsSet("days_names", days); }, [days]);

      function addNewDay() {
        setDays(prev => prev.concat(["Day " + (prev.length + 1)]));
      }

      function editDayName(idx) {
        const next = prompt("Edit Day name", days[idx]);
        if (next && next.trim()) {
          setDays(prev => prev.map((v, i) => i === idx ? next.trim() : v));
        }
      }

      async function collectAllData() {
        const all = {};
        for (let day = 1; day <= days.length; day++) {
          const data = ensureDayShape(day, loadDay(day));
          all["day_" + day] = { pages: data.pages, styles: data.styles, locks: data.locks };
        }
        // also keep names list so remote has your grid names
        all["_days_names"] = days;
        return all;
      }

      async function applyAllData(remote) {
        // restore day blobs
        const entries = Object.entries(remote || {});
        for (let i = 0; i < entries.length; i++) {
          const [k, v] = entries[i];
          if (!k.startsWith("day_")) continue;
          const num = Number(k.split("_")[1]);
          if (!Number.isFinite(num)) continue;
          const fixed = ensureDayShape(num, v || {});
          saveDay(num, fixed);
        }
        // restore names
        if (Array.isArray(remote?._days_names) && remote._days_names.length) {
          lsSet("days_names", remote._days_names);
          setDays(remote._days_names);
        } else {
          // extend if needed to match highest day
          let maxDay = 0;
          for (const [k] of entries) {
            if (k.startsWith("day_")) {
              const n = Number(k.split("_")[1]);
              if (n > maxDay) maxDay = n;
            }
          }
          if (maxDay > days.length) {
            setDays(prev => {
              const copy = prev.slice();
              for (let i = prev.length; i < maxDay; i++) copy.push("Day " + (i + 1));
              return copy;
            });
          }
        }
      }

      async function exportAll() {
        const data = await collectAllData();
        downloadJson("all_day_data.json", data);
        toast("Exported all data");
      }

      async function importAll() {
        try {
          const data = await openFilePickerJson();
          if (!data || typeof data !== "object") throw new Error("Invalid JSON");
          await applyAllData(data);
          toast("Data imported successfully");
        } catch (e) {
          toast("Error importing: " + (e?.message || e));
        }
      }

      // ====== CLOUD ACTIONS ======
      async function setMasterKeyPrompt() {
        const current = getMasterKey();
        const next = prompt("Paste your JSONBin Master Key", current || "");
        if (next !== null) {
          if (!next.trim()) { toast("Key cleared"); setMasterKey(""); return; }
          setMasterKey(next.trim());
          toast("Master Key saved locally");
        }
      }

      async function setBinIdPrompt() {
        const current = getBinId();
        const next = prompt("Set your JSONBin Bin ID", current || "");
        if (next !== null) {
          if (!next.trim()) { toast("Bin ID cleared"); setBinId(""); return; }
          setBinId(next.trim());
          toast("Bin ID saved");
        }
      }

      async function createNewBin() {
        try {
          setBusy(true);
          const record = await collectAllData();
          const id = await jsonbinCreate(record);
          setBinId(id);
          toast("Created private Bin: " + id);
        } catch (e) {
          toast(e.message || String(e));
        } finally {
          setBusy(false);
        }
      }

      async function saveToCloud() {
        const binId = getBinId();
        if (!binId) {
          toast("No Bin ID set. Use 'Create New Bin' or 'Set Bin ID' first.");
          return;
        }
        try {
          setBusy(true);
          const record = await collectAllData();
          await jsonbinUpdate(binId, record);
          toast("Cloud save complete");
        } catch (e) {
          toast(e.message || String(e));
        } finally {
          setBusy(false);
        }
      }

      async function loadFromCloud() {
        const binId = getBinId();
        if (!binId) {
          toast("No Bin ID set. Use 'Create New Bin' or 'Set Bin ID' first.");
          return;
        }
        try {
          setBusy(true);
          const remote = await jsonbinRead(binId); // reads latest version
          if (!remote || typeof remote !== "object") throw new Error("Empty or invalid cloud data");
          await applyAllData(remote);
          toast("Cloud load complete");
        } catch (e) {
          toast(e.message || String(e));
        } finally {
          setBusy(false);
        }
      }

      return (
        <div className="min-h-screen bg-gradient-to-b from-white to-slate-50">
          <header className="sticky top-0 z-10 backdrop-blur bg-white/70 border-b border-black/10">
            <div className="max-w-6xl mx-auto px-4 py-3 flex items-center gap-2">
              <h1 className="text-xl font-semibold">Dynamic Days Grid</h1>
              <div className="flex-1" />
              <IconBtn title="Export All Data" onClick={exportAll}>⬇️</IconBtn>
              <IconBtn title="Import All Data" onClick={importAll}>⬆️</IconBtn>

              <div className="relative">
                <IconBtn title="Cloud / Settings" onClick={() => setCloudOpen(v => !v)}>⚙️</IconBtn>
                {cloudOpen && (
                  <div className="absolute right-0 mt-2 w-72 rounded-xl border border-black/10 bg-white shadow-lg p-3 space-y-2">
                    <div className="text-sm font-semibold">Cloud Sync (JSONBin)</div>
                    <div className="text-xs text-slate-500">
                      Master Key & Bin ID are stored only in your browser.
                    </div>
                    <div className="flex gap-2">
                      <OutlineBtn onClick={setMasterKeyPrompt}>Set Master Key</OutlineBtn>
                      <OutlineBtn onClick={setBinIdPrompt}>Set Bin ID</OutlineBtn>
                    </div>
                    <div className="flex gap-2">
                      <PrimaryBtn disabled={busy} onClick={createNewBin}>
                        {busy ? "Working…" : "Create New Bin"}
                      </PrimaryBtn>
                    </div>
                    <div className="flex gap-2">
                      <PrimaryBtn disabled={busy} onClick={saveToCloud}>
                        {busy ? "Working…" : "Save to Cloud"}
                      </PrimaryBtn>
                      <OutlineBtn disabled={busy} onClick={loadFromCloud}>
                        {busy ? "Working…" : "Load from Cloud"}
                      </OutlineBtn>
                    </div>
                    <div className="text-xs text-slate-500">
                      Tip: you can keep multiple Bins; just change the Bin ID to switch.
                    </div>
                  </div>
                )}
              </div>
            </div>
          </header>

          <main className="max-w-6xl mx-auto px-4 py-6">
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3">
              {days.map((label, idx) => (
                <div
                  key={idx}
                  className="rounded-xl bg-purple-100 shadow-sm hover:shadow cursor-pointer select-none p-6 flex items-center justify-center text-center"
                  onClick={() => onOpenDay(idx + 1)}
                  onContextMenu={(e) => {
                    e.preventDefault();
                    editDayName(idx);
                  }}
                  title="Right-click to rename"
                >
                  <span className="font-semibold text-slate-900">{label}</span>
                </div>
              ))}
            </div>
          </main>

          <footer className="fixed left-0 right-0 bottom-0">
            <div className="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
              <PrimaryBtn onClick={onOpenGridManager}>Switch to Grid Manager</PrimaryBtn>
              <PrimaryBtn onClick={addNewDay}>Add New Day</PrimaryBtn>
            </div>
          </footer>
        </div>
      );
    }

    function App() {
      const [view, setView] = useState({ name: "grid" });
      return (
        <div className="font-[system-ui] text-slate-900">
          {view.name === "grid" && (
            <DayGridPage
              onOpenDay={(idx) => setView({ name: "day", dayIndex: idx })}
              onOpenGridManager={() => setView({ name: "gridmgr" })}
            />
          )}
          {view.name === "day" && (
            <DayTextPage dayIndex={view.dayIndex} onBack={() => setView({ name: "grid" })} />
          )}
          {view.name === "gridmgr" && (
            <GridManagerPage onBack={() => setView({ name: "grid" })} />
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
